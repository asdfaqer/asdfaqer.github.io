
<!DOCTYPE html>
<html>
<head>
    <title>NN Classification Demo</title>
</head>
<body>
    <h1>NN Classification Demo</h1>
    <p>Below is a demonstration of neural network classification in action.</p>
    
    <button type="button">Distribution 1</button>
    <button type="button">Distribution 2</button>
    <button type="button">Distribution 3</button>

    <button onclick="classify()">Classify</button>
    
    <select id="mySelect">
        <option value="line of best fit">line of best fit</option>
        <option value="relu classification">relu classification</option>
        <option value="tanh classification">tanh classification</option>
    </select>
    
    <div id="my-div">
        <canvas id="myCanvas" width="500" height="500" style="border:1px solid #000000;">
            Your browser does not support the HTML5 canvas element.
        </canvas>
        
        <script>
            const CANVAS_WIDTH = 500;
            const CANVAS_HEIGHT = 500;
            var c = document.getElementById("myCanvas");
            var ctx = c.getContext("2d");
            
            function draw_point(x, y, color) {
                ctx.fillStyle = color;
                ctx.fillRect(x, y, 3, 3);
            }
            
            function draw_line(x1, y1, x2, y2, color) {  
                ctx.strokeStyle = color;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
            
            function draw_points_list(points_list) {
                for (let i = 0; i < points_list.length; i++) {
                    draw_point(points_list[i][0], points_list[i][1], points_list[i][2]);
                }
            }

            // --- NEW: Function to draw the light-colored background ---
            function drawBackground(slope, y_int) {
                const lightRed = 'rgb(255, 220, 220)';
                const lightGreen = 'rgb(220, 255, 220)';
                const step = 5; // Draw a 5x5 pixel square for performance

                for (let x = 0; x < CANVAS_WIDTH; x += step) {
                    for (let y = 0; y < CANVAS_HEIGHT; y += step) {
                        const prediction_is_red = (y < slope * x + y_int);
                        ctx.fillStyle = prediction_is_red ? lightRed : lightGreen;
                        ctx.fillRect(x, y, step, step);
                    }
                }
            }
            
            const points = [[61, 436, 'rgb(0, 150, 0)'], [130, 337, 'rgb(0, 150, 0)'], [66, 329, 'rgb(0, 150, 0)'], [83, 475, 'rgb(0, 150, 0)'], [290, 495, 'rgb(0, 150, 0)'], [134, 294, 'rgb(0, 150, 0)'], [285, 432, 'rgb(0, 150, 0)'], [194, 137, 'rgb(150, 0, 0)'], [185, 257, 'rgb(0, 150, 0)'], [412, 349, 'rgb(150, 0, 0)'], [50, 479, 'rgb(0, 150, 0)'], [77, 373, 'rgb(0, 150, 0)'], [283, 98, 'rgb(150, 0, 0)'], [426, 42, 'rgb(150, 0, 0)'], [443, 225, 'rgb(150, 0, 0)'], [345, 29, 'rgb(150, 0, 0)'], [421, 374, 'rgb(150, 0, 0)'], [199, 81, 'rgb(150, 0, 0)'], [52, 494, 'rgb(0, 150, 0)'], [214, 248, 'rgb(0, 150, 0)'], [72, 389, 'rgb(0, 150, 0)'], [487, 59, 'rgb(150, 0, 0)'], [274, 473, 'rgb(0, 150, 0)'], [103, 91, 'rgb(150, 0, 0)'], [139, 240, 'rgb(0, 150, 0)'], [444, 131, 'rgb(150, 0, 0)'], [240, 389, 'rgb(0, 150, 0)'], [81, 293, 'rgb(0, 150, 0)'], [78, 189, 'rgb(0, 150, 0)'], [22, 182, 'rgb(0, 150, 0)'], [292, 119, 'rgb(150, 0, 0)'], [289, 161, 'rgb(150, 0, 0)'], [352, 260, 'rgb(150, 0, 0)'], [215, 62, 'rgb(150, 0, 0)'], [50, 125, 'rgb(0, 150, 0)'], [493, 473, 'rgb(150, 0, 0)'], [142, 155, 'rgb(0, 150, 0)'], [27, 310, 'rgb(0, 150, 0)'], [265, 251, 'rgb(150, 0, 0)'], [52, 166, 'rgb(0, 150, 0)'], [408, 73, 'rgb(150, 0, 0)'], [130, 71, 'rgb(150, 0, 0)'], [270, 21, 'rgb(150, 0, 0)'], [53, 191, 'rgb(0, 150, 0)'], [177, 185, 'rgb(0, 150, 0)'], [383, 164, 'rgb(150, 0, 0)'], [188, 349, 'rgb(0, 150, 0)'], [226, 62, 'rgb(150, 0, 0)'], [397, 226, 'rgb(150, 0, 0)'], [300, 451, 'rgb(0, 150, 0)'], [308, 221, 'rgb(150, 0, 0)'], [296, 157, 'rgb(150, 0, 0)'], [345, 251, 'rgb(150, 0, 0)'], [207, 429, 'rgb(0, 150, 0)'], [423, 42, 'rgb(150, 0, 0)'], [370, 402, 'rgb(0, 150, 0)'], [201, 461, 'rgb(0, 150, 0)'], [160, 437, 'rgb(0, 150, 0)'], [259, 17, 'rgb(150, 0, 0)'], [218, 125, 'rgb(150, 0, 0)'], [9, 179, 'rgb(0, 150, 0)'], [372, 375, 'rgb(0, 150, 0)'], [322, 297, 'rgb(150, 0, 0)'], [497, 221, 'rgb(150, 0, 0)'], [309, 228, 'rgb(150, 0, 0)'], [337, 210, 'rgb(150, 0, 0)'], [500, 214, 'rgb(150, 0, 0)'], [419, 39, 'rgb(150, 0, 0)'], [367, 71, 'rgb(150, 0, 0)'], [350, 368, 'rgb(0, 150, 0)'], [355, 464, 'rgb(0, 150, 0)'], [336, 80, 'rgb(150, 0, 0)'], [490, 63, 'rgb(150, 0, 0)'], [451, 264, 'rgb(150, 0, 0)'], [470, 52, 'rgb(150, 0, 0)'], [299, 319, 'rgb(0, 150, 0)'], [294, 427, 'rgb(0, 150, 0)'], [43, 403, 'rgb(0, 150, 0)'], [329, 236, 'rgb(150, 0, 0)'], [453, 213, 'rgb(150, 0, 0)'], [422, 150, 'rgb(150, 0, 0)'], [438, 20, 'rgb(150, 0, 0)'], [238, 447, 'rgb(0, 150, 0)'], [290, 111, 'rgb(150, 0, 0)'], [376, 297, 'rgb(150, 0, 0)'], [247, 396, 'rgb(0, 150, 0)'], [234, 492, 'rgb(0, 150, 0)'], [132, 305, 'rgb(0, 150, 0)'], [423, 106, 'rgb(150, 0, 0)'], [102, 282, 'rgb(0, 150, 0)'], [360, 434, 'rgb(0, 150, 0)'], [53, 191, 'rgb(0, 150, 0)'], [58, 420, 'rgb(0, 150, 0)'], [443, 402, 'rgb(150, 0, 0)'], [164, 454, 'rgb(0, 150, 0)'], [81, 454, 'rgb(0, 150, 0)'], [366, 110, 'rgb(150, 0, 0)'], [265, 438, 'rgb(0, 150, 0)'], [172, 498, 'rgb(0, 150, 0)'], [251, 65, 'rgb(150, 0, 0)'], [431, 315, 'rgb(150, 0, 0)'], [109, 142, 'rgb(0, 150, 0)'], [240, 382, 'rgb(0, 150, 0)'], [496, 24, 'rgb(150, 0, 0)'], [209, 138, 'rgb(150, 0, 0)'], [160, 130, 'rgb(150, 0, 0)'], [328, 102, 'rgb(150, 0, 0)'], [223, 431, 'rgb(0, 150, 0)'], [287, 36, 'rgb(150, 0, 0)'], [166, 421, 'rgb(0, 150, 0)'], [164, 395, 'rgb(0, 150, 0)'], [150, 226, 'rgb(0, 150, 0)'], [152, 435, 'rgb(0, 150, 0)'], [347, 487, 'rgb(0, 150, 0)'], [262, 37, 'rgb(150, 0, 0)'], [464, 26, 'rgb(150, 0, 0)'], [460, 256, 'rgb(150, 0, 0)'], [349, 124, 'rgb(150, 0, 0)'], [135, 319, 'rgb(0, 150, 0)'], [97, 268, 'rgb(0, 150, 0)'], [374, 301, 'rgb(150, 0, 0)'], [195, 285, 'rgb(0, 150, 0)'], [373, 186, 'rgb(150, 0, 0)'], [106, 366, 'rgb(0, 150, 0)'], [301, 251, 'rgb(150, 0, 0)'], [236, 177, 'rgb(150, 0, 0)'], [64, 91, 'rgb(0, 150, 0)'], [217, 80, 'rgb(150, 0, 0)'], [4, 311, 'rgb(0, 150, 0)'], [22, 354, 'rgb(0, 150, 0)'], [470, 275, 'rgb(150, 0, 0)'], [392, 310, 'rgb(150, 0, 0)'], [64, 10, 'rgb(150, 0, 0)'], [487, 92, 'rgb(150, 0, 0)'], [285, 308, 'rgb(0, 150, 0)'], [436, 425, 'rgb(150, 0, 0)'], [132, 97, 'rgb(150, 0, 0)'], [128, 451, 'rgb(0, 150, 0)'], [110, 373, 'rgb(0, 150, 0)'], [49, 66, 'rgb(0, 150, 0)'], [332, 32, 'rgb(150, 0, 0)'], [43, 65, 'rgb(0, 150, 0)'], [353, 75, 'rgb(150, 0, 0)'], [333, 140, 'rgb(150, 0, 0)'], [348, 375, 'rgb(0, 150, 0)'], [151, 70, 'rgb(150, 0, 0)'], [116, 399, 'rgb(0, 150, 0)'], [66, 30, 'rgb(150, 0, 0)'], [66, 421, 'rgb(0, 150, 0)'], [280, 104, 'rgb(150, 0, 0)']];
            // Draw the initial points
            for (let inx = 0; inx < points.length; inx++) {
                draw_point(points[inx][0], points[inx][1], points[inx][2]);
            }
        </script> 
    </div>

    <script>
        // --- State variables for our animation loop ---
        let best_slope, best_y_int, best_score, currentIteration;
        let animationFrameId = null; // To keep track of the animation request
        const maxIterations = 1000;
        const red_label = 'rgb(150, 0, 0)';

        // This function will be called to start or restart the process
        function startFindingBestFit() {

            // If an animation is already running, cancel it before starting a new one
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            // --- Reset the state for a new search ---
            best_slope = -1;
            best_y_int = 450;
            best_score = 0;
            currentIteration = 0;
            
            // Clear the canvas and redraw the points to start fresh
            ctx.clearRect(0, 0, c.width, c.height);
            draw_points_list(points);

            // Kick off the animation loop
            findBestFitStep();
        }

        // --- This function performs ONE STEP of the search ---
        function findBestFitStep() {
            // 1. Check the stop condition
            if (currentIteration >= maxIterations) {
                console.log("Search complete. Final score:", best_score);
                return; // Stop the animation
            }

            // 2. Perform one iteration of the search logic
            let guess_slope = Math.tan(Math.atan(best_slope) + (Math.random() - 0.5) * 360 / (1 + Math.log(currentIteration + 1)));
            let guess_y_int = best_y_int + (Math.random() - 0.5) * 1000 / (1 + Math.log(currentIteration + 1));
            let current_score = 0;

            for (let i = 0; i < points.length; i++) {
                const p = points[i];
                const prediction_is_red = (p[1] < guess_slope * p[0] + guess_y_int);
                if (prediction_is_red === (p[2] === red_label)) {
                    current_score++;
                }
            }

            // 3. If we found a new best, UPDATE and REDRAW
            if (current_score > best_score) {
                best_score = current_score;
                best_slope = guess_slope;
                best_y_int = guess_y_int;
                
                console.log(`New best at iteration ${currentIteration}: score ${best_score}`);

                // --- MODIFIED: Redraw the canvas with background, points, and line ---
                // 1. Draw the new light-colored background based on the classifier
                drawBackground(best_slope, best_y_int);

                // 2. Draw the original, darker points on top of the background
                draw_points_list(points);

                // 3. Draw the new best-fit line on top of everything
                draw_line(0, best_y_int, CANVAS_WIDTH, best_y_int + CANVAS_WIDTH * best_slope, 'blue');
            }

            // 4. Schedule the next step
            currentIteration++;
            animationFrameId = requestAnimationFrame(findBestFitStep);
        }

        function classify() {
            const mySelect = document.getElementById('mySelect');
            if (mySelect.value !== 'line of best fit') {
                alert("This classifier is not implemented yet.");
                return;
            }
            else if (mySelect.value === 'line of best fit') {
                startFindingBestFit();
                // Note: The rest of this function will run before startFindingBestFit finishes.
                // The animation loop is the part that visually updates the canvas.
            }
        }
    </script>
</body>
</html>
